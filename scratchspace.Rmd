---
title: "Historic district analysis"
author: "Pete Rodrigue & Bob Ward"
date: "2025-08-23"
output: html_document
---

This Rmarkdown file shows the code we used to analyze demographic change over time in and outside of historic districts. 


```{r setup}
knitr::opts_chunk$set(echo = TRUE, message=F, warning=F, fig.width = 11.5, fig.height = 6.5)
library(readr)
library(sf)
library(leaflet)
library(rstudioapi)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(plotly)
library(did)
```

Set working directory to the place this script is saved:

```{r}
# Getting the path of your current open file
current_path = rstudioapi::getActiveDocumentContext()$path 
setwd(dirname(current_path))
```

# Load and clean data

Load our data. We'll first do the analysis using Census tracts, and then later use Census blocks.

```{r}
# load data that has the dates the historic districts were designated
# comes from here: https://planning.dc.gov/page/dc-historic-districts
# hd_data <- readr::read_csv("https://docs.google.com/spreadsheets/d/1Ajl1iAS0NRB7vk_UFDveeWzGkwf3tuiDo-zV9_wtzRM/gviz/tq?tqx=out:csv&sheet=data")
hd_data <- readr::read_csv("hd_data/data.csv")

# load the historic district boundary shape files
# comes from here: https://opendata.dc.gov/datasets/DCGIS::historic-districts/about 
hd_shp <- sf::st_read("Historic_Districts/Historic_Districts.shp")

# load the 2022 ward shape files
# comes from here: https://opendata.dc.gov/datasets/DCGIS::wards-from-2022/about
ward_shp <- sf::st_read("Wards_from_2022/Wards_from_2022.shp")

# load the zoning map:
# comes from here: https://opendata.dc.gov/datasets/DCGIS::zoning-boundaries-zoning-regulations-of-2016/about
zone_shp <- sf::st_read("zoning/Zoning_Boundaries_(Zoning_Regulations_of_2016).shp")

# load & clean census tract data
# please see https://opendata.dc.gov/datasets/DCGIS::census-tracts-in-1970/about
# for example, for more details on variable names
load_clean_tracts <- function(geo_id_var, black_var, white_var, totpop_var, year) {
  # Loads the shapefile, removes unneeded columns, calculates the tract area in meters^2
  shp <- sf::st_read(paste0("tract_data/Census_Tracts_in_", year, 
                            "/Census_Tracts_in_", year, ".shp")) 
  shp <- shp %>% 
    rename("geo_id" = !!sym(geo_id_var),
           "n_black" = !!sym(black_var),
           "n_white" = !!sym(white_var),
           "n_tot" = !!sym(totpop_var)
           ) %>%
    select("geo_id", starts_with("n_")) %>%
    mutate(n_other = n_tot - (n_black + n_white),
           year = year)
  shp <- sf::st_transform(shp, 4326)
  shp$geo_area_meters <- sf::st_area(shp)
  
  return(shp %>% select("year", "geo_id", "n_tot", "n_black", "n_white", "n_other", "geo_area_meters", "geometry"))
}


clean_block_data <- function(shp, df, shp_b_id, df_b_id, var_prefix, df_n_black, df_n_white, drop_var="", year) {
  shp <- shp %>% select(!!sym(shp_b_id)) %>% rename("geo_id" = !!sym(shp_b_id))
  if (drop_var!="") {df <- df %>% select(-!!sym(drop_var))}
  df <- df %>% 
    select(!!sym(df_b_id), starts_with(var_prefix)) %>%
    rowwise() %>%
    mutate(n_tot = sum(c_across(starts_with(var_prefix))))
    
  df <- df %>%
    rename("geo_id" = !!sym(df_b_id),
           "n_black" = !!sym(df_n_black),
           "n_white" = !!sym(df_n_white)) %>%
    select(-starts_with(var_prefix)) %>%
    mutate(n_other = n_tot - (n_black + n_white))
  
  shp <- dplyr::left_join(shp, df, by="geo_id")
  shp <- sf::st_transform(shp, 4326)
  shp$geo_area_meters <- sf::st_area(shp)
  shp$year <- year
  
  return(shp)
}


# Load raw block data:
  
# b70_shp <- sf::st_read("block_shapes/US_block_1970/US_block_1970.shp")
# b70_shp <- b70_shp[b70_shp$STATE70=="11",]
# sf::st_write(b70_shp, "block_shapes/DC_block_1970/DC_block_1970.shp")

b70_shp <- sf::st_read("block_shapes/DC_block_1970/DC_block_1970.shp")
b80_shp <- sf::st_read("block_shapes/DC_block_1980/DC_block_1980.shp")
b90_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2000_110_block_1990/DC_block_1990.shp")
b00_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2000_110_block_2000/DC_block_2000.shp")
b10_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2010_110_block_2010/DC_block_2010.shp")
b20_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2020_110_block_2020/DC_block_2020.shp")

b70_df <- readr::read_csv("block_data/nhgis0093_ds96_1970_block.csv")
b80_df <- readr::read_csv("block_data/nhgis_ds104_1980_block_11.csv")
b90_df <- readr::read_csv("block_data/nhgis0092_ds120_1990_block.csv")
b00_df <- readr::read_csv("block_data/nhgis0092_ds147_2000_block.csv")
b10_df <- readr::read_csv("block_data/nhgis0092_ds172_2010_block.csv")
b20_df <- readr::read_csv("block_data/nhgis0092_ds258_2020_block.csv")

# 1970 block data has to be specially cleaned, see https://forum.ipums.org/t/race-ethnicity-data-at-a-block-level-from-1970/6178
b70_df$c_black <- b70_df$CM6001 + b70_df$CM6002
b70_df$c_other <- b70_df$CM6003 + b70_df$CM6004
b70_df$c_white <- b70_df$CM5001 + b70_df$CM5002 - b70_df$c_black - b70_df$c_other
```

Clean tracts for 1960 and blocks for all later decades:


```{r, results="hide", error=F, message=F, warning=F}
# turn off spherical geometry (s2)
sf_use_s2(FALSE)

# need to fix broken geometries:
fix_geo_if_broken <- function(shp) {
  if (min(sf::st_is_valid(shp)) == 0) {
    print("Fixing geometry...")
    return(sf::st_make_valid(shp))
  } else {
      return(shp)
    }
  }

zone_shp <- fix_geo_if_broken(zone_shp)
hd_shp <- fix_geo_if_broken(hd_shp)
ward_shp <- fix_geo_if_broken(ward_shp)
b70_shp <- fix_geo_if_broken(b70_shp)
b80_shp <- fix_geo_if_broken(b80_shp)
b90_shp <- fix_geo_if_broken(b90_shp)
b10_shp <- fix_geo_if_broken(b10_shp)
b20_shp <- fix_geo_if_broken(b20_shp)


b60_shp <- load_clean_tracts("GISJOIN", "B58013", "B58011", "CA4001", 1960)
b60_shp <- fix_geo_if_broken(b60_shp)
# in an older version of this analysis, I ran everything using tracts;
# you can uncomment the lines below to load the tract data and do that
# b70_shp <- load_clean_tracts("GISJOIN", "CEB03", "CEB01", "CY7001", 1970) 
# b80_shp <- load_clean_tracts("GISJOIN", "C9D003", "C9D001", "C7L001", 1980)
# b90_shp <- load_clean_tracts("TRACTNO", "BLACK", "WHITE", "POPULATION", 1990)
# b00_shp <- load_clean_tracts("TRACTNO", "BLACK", "WHITE", "TOTAL", 2000)
# b10_shp <- load_clean_tracts("TRACT", "P0010004", "P0010003", "P0010001", 2010)
# b20_shp <- load_clean_tracts("TRACT", "P0010004", "P0010003", "P0010001", 2020)
gc()

b70_shp <- clean_block_data(b70_shp, b70_df, "GISJOIN", "GISJOIN", "c_", "c_black", "c_white", year=1970)
b80_shp <- clean_block_data(b80_shp, b80_df, "GISJOIN", "GISJOIN", "C9D0", "C9D002", "C9D001", year=1980)
b90_shp <- clean_block_data(b90_shp, b90_df, "GISJOIN", "GISJOIN", "EUY0", "EUY002", "EUY001", year=1990)
b00_shp <- clean_block_data(b00_shp, b00_df, "GISJOIN", "GISJOIN", "FYE0", "FYE002", "FYE001", year=2000)
b10_shp <- clean_block_data(b10_shp, b10_df, "GISJOIN", "GISJOIN", "H7X", "H7X003", "H7X002", "H7X001", year=2010)
b20_shp <- clean_block_data(b20_shp, b20_df, "GISJOIN", "GISJOIN", "U7J", "U7J003", "U7J002", "U7J001", year=2020)

rm(b70_df, b80_df, b90_df, b00_df, b10_df, b20_df)

gc()
```

Merge historic district (HD) data onto HD shapefile, subset to only look at neighborhood HDs:

```{r}
hd_shp <- dplyr::left_join(x = hd_shp, y = hd_data, by = "UNIQUEID")
hd_shp <- hd_shp[hd_shp$Neighborhood_HD==1,]

```

Transform shape files to mercator projection:

```{r}
# convert to mercator projection
zone_shp <- sf::st_transform(zone_shp, 4326)
hd_shp <- sf::st_transform(hd_shp, 4326)
ward_shp <- sf::st_transform(ward_shp, 4326)
```




# Initial descriptive statistics

Let's overlay HDs onto DC's zoning map. 

```{r}
# list zones:
zones_list <- sort(unique(zone_shp$ZR16))
housing_zones <- zones_list[grep(x=zones_list, pattern = "^R|^MU")]
# subset zones to mostly-housing zones 
zone_shp <- zone_shp[zone_shp$ZR16 %in% housing_zones,]

# create simplified labels
zone_shp$ZR16_simple <- "Other"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^RA-")] <- "Apartment zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^R-")] <- "Residential zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^RF-")] <- "Residential flat zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^MU-")] <- "Mixed use zones"

# show on a map:
factpal <- colorFactor(palette = "Set1", domain = zone_shp$ZR16_simple)

leaflet(zone_shp) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~factpal(ZR16_simple), # Apply the color function
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~ZR16,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = TRUE
        )
  ) %>%
  addLegend(pal = factpal, values = ~ZR16_simple, opacity = 0.7, title = NULL,
    position = "bottomright")
```


Calculate the total amount of residential and MU land in DC:

```{r}
zone_shp$area_meters <- sf::st_area(zone_shp)
zone_shp$area_acres <- as.vector(zone_shp$area_meters * 0.000247105)
total_zone_acres <- sum(zone_shp$area_acres, na.rm=T)
```


Total and % of land area covered by HDs over time:

```{r}
# get shape areas:
hd_shp$area_meters <- sf::st_area(hd_shp)
hd_shp$area_acres <- as.vector(hd_shp$area_meters * 0.000247105)

years <- c(1960, 1970, 1980, 1990, 2000, 2010, 2025)
land_areas <- rep(NA, length(years))
counter <- 1
for (year in years) { # Land area covered by HDs by year:
  land_area <- sum(hd_shp$area_acres[hd_shp$desig_date < year])
  land_areas[counter] <- land_area
  counter <- counter + 1
}

p <- data.frame(years, land_areas, round(100*land_areas / total_zone_acres,0))
names(p) <- c("Year", 
              "Area covered by by Historic Districts, in Acres",
              "Percent of 2016 residential zone covered by Neighborhood HD")
plot1 <-
  ggplot(p, 
       aes(x=Year, 
           y=`Area covered by by Historic Districts, in Acres`)) + 
  geom_bar(stat = "identity", fill="#0f9535") +
  geom_text(aes(label = round(`Area covered by by Historic Districts, in Acres`, 0), vjust = -1.7)) +
  ylab("Acres") +
  theme_minimal() +
  ggtitle('Acres covered by "neighborhood historic districts"\nhas steadily increased over time')

plot2 <-
  ggplot(p, 
       aes(x=Year, 
           y=`Percent of 2016 residential zone covered by Neighborhood HD`)) + 
  geom_line(color="#0f9535", size=.75) +
  geom_point(color="#0f9535") +
  geom_text(aes(label = paste0(`Percent of 2016 residential zone covered by Neighborhood HD`, "%")), vjust = -1.7) +
  theme_minimal() +
  ylab("Percent") +
  ggtitle('And the % of residential area covered\nby HDs has more than doubled since 1980')

plot1 + plot2
```


Let's quickly compare which HDs were designated before vs after 1980:

```{r}

hd_shp$decade_desig <- hd_shp$desig_date

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group= "Designated before 1980",
              data=hd_shp[hd_shp$flag_1980==1,],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "Designated after 1980",
              data=hd_shp[hd_shp$flag_1980==0,],
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("Designated before 1980", "Designated after 1980"),
    options = layersControlOptions(collapsed = FALSE)
  )

```

We'll remove some very small HDs for the next part (like HDs that are a single circle):

```{r}
# Drop some very small HDs that are like a single circle
# We just dropped anything smaller than 10 acres
hd_shp <-
  hd_shp %>%
  filter(!(LABEL %in% c("Emerald St HD",
                       "Grant Rd HD",
                       "Mount Vernon Triangle HD",
                       "Grant Circle HD",
                       "Union Market"
                       )))

```




# Demographic change analysis

Now let's look and see how HDs changed over time, in terms of % black residents and % white residents, compared to nearby neighborhoods (groups of blocks) that were not in HDs.

This will have a few steps:

1. Take a given HD.
2. Get the intersection of the HD with census tracts (in 1960) and blocks (in 1970 to 2020). If at least X% of the census tract area is in the HD, we'll count it as part of the HD.
3. Create a buffer around the HD of distance Y. Run another intersection with the census tracts/blocks and that buffer. Count any tracts/blocks that touch the buffer but are not in an HD as comparison tracts. 
4. Note the % of white and black residents in each HD and those HDs comparison tracts/blocks.
5. See how those respective percentages change over time. 


Function to find which tracts/blocks are in which HDs:

```{r}
get_geos_in_hd <- function(shp, min_pct, year) {
  # This function gets the tracts that are in each HD in a given year
  # shp: the tract or block shapefile (an sf shapefile object)
  # min_pct: the minimum % of the tract or block that must be in the HD to count as part of the HD (a decimal # between 0 and 1)
  # year: the year (an integer like 1980)
  i <- sf::st_intersection(x=shp, y=hd_shp)
  i$i_area <- sf::st_area(i)
  i$pct_of_geo_area <- as.vector(i$i_area / i$geo_area_meters)
  
  geos_in_hd <- i[i$pct_of_geo_area > min_pct, 
                    c("year", "geo_id", "LABEL",
                      "n_tot", "n_black", "n_white", "n_other",
                      "desig_date", "pct_of_geo_area")]
  
  geos_in_hd$geo_area <- sf::st_area(geos_in_hd)
  
  geos_in_hd_summary <-
    geos_in_hd %>%
    mutate(n_tot_prorated = n_tot * pct_of_geo_area,
           n_black_prorated = n_black * pct_of_geo_area,
           n_white_prorated = n_white * pct_of_geo_area,
           n_other_prorated = n_other * pct_of_geo_area) %>%
    select("year", "LABEL", "geo_id", starts_with("n_"), "desig_date", "geo_area") %>%
    group_by(LABEL) %>%
      summarise(n_tot = sum(n_tot, na.rm=T),
                n_black = sum(n_black, na.rm=T),
                n_white = sum(n_white, na.rm=T),
                n_other = sum(n_other, na.rm=T),
                n_tot_prorated = sum(n_tot_prorated, na.rm=T),
                n_black_prorated = sum(n_black_prorated, na.rm=T),
                n_white_prorated = sum(n_white_prorated, na.rm=T),
                n_other_prorated = sum(n_other_prorated, na.rm=T),
                desig_year = max(desig_date, na.rm=T),
                geo_area = sum(geo_area, na.rm=T)) %>%
    mutate(desig_yet = ifelse(desig_year<year, 1, 0), 
           year = year,
           pop_dens = n_tot / geo_area)
  
    rv = list("geos_in_hd"=geos_in_hd, "summary"=sf::st_drop_geometry(geos_in_hd_summary))
    
    return(rv)
}


```

Function to find which tracts/blocks are nearby but not inside the HDs:

```{r}
#' Get neighboring geographic units (tracts/blocks) around Historic Districts (HDs)
#'
#' This function identifies geographic units that are adjacent to Historic Districts
#' by creating buffers around HDs and finding intersecting geographic units, while
#' excluding units already classified as within HDs and those where HDs occupy
#' a large portion of the geographic unit.
#'
#' @param hd_shp sf object containing Historic District boundaries
#' @param geo_shp sf object containing geographic units (census tracts/blocks)
#' @param buffer_dist numeric buffer distance (in same units as CRS) around HDs
#' @param geos_in_hd list containing geographic units already within HDs
#' @param remove_geo_thresh numeric threshold (0-1) for removing geos with large HD overlap
#' @param year numeric year for designation comparison
#'
#' @return list with three elements: buffers, neighbor_geos, neighbor_geos_summary
#' 
get_neighbor_geos <- function(hd_shp, geo_shp, buffer_dist, geos_in_hd, remove_geo_thresh, year) {
  # STEP 1: Create buffer zones around Historic Districts
  # Creates a buffer of specified distance around each HD boundary
  # This defines the "neighborhood" area we're interested in
  b <- sf::st_buffer(hd_shp, dist = buffer_dist)
  # STEP 2: Find geographic units that intersect with HD buffers
  # This identifies all census tracts/blocks that fall within or overlap
  # the buffer zones around Historic Districts
  i <- sf::st_intersection(x=geo_shp, y=b)
  # STEP 3: Remove geographic units already classified as within an HD
  # Excludes any tracts/blocks that have already been identified as being
  # inside Historic District boundaries (not just neighboring them)
  i <- i[!(i$geo_id %in% geos_in_hd$geos_in_hd$geo_id),]
  # STEP 4: Calculate HD area coverage within each geographic unit
  # This section removes geographic units where Historic Districts occupy
  # more than the specified threshold percentage of the unit's area
  
  # Calculate total area of each Historic District
  hd_shp$area_meters <- sf::st_area(hd_shp)
  # Find intersection between all geographic units and Historic Districts
  # This shows where HDs actually overlap with census tracts/blocks
  hd_geo <- sf::st_intersection(x=geo_shp, y=hd_shp)
  # Calculate the area of HD-geography intersection
  hd_geo$intersect_area <- sf::st_area(hd_geo)
  # Calculate what percentage of each HD falls within each geographic unit
  # This helps identify cases where most of an HD is contained within a single tract/block
  hd_geo$pct_area <- as.vector(hd_geo$intersect_area / hd_geo$area_meters)
  # Identify geographic units to remove (those with HD coverage above threshold)
  # These are units where Historic Districts occupy too large a portion to be
  # considered merely "neighboring" - they likely contain significant HD area
  geos_to_remove <- hd_geo$geo_id[hd_geo$pct_area > remove_geo_thresh]
  # Remove the problematic geographic units from our neighboring list
  neighboring_geos <- i[!(i$geo_id %in% geos_to_remove),]
  
  # STEP 5: Create final neighboring geographic units dataset
  # Get the full geographic data for the identified neighboring units
  neighboring_geos <- geo_shp[geo_shp$geo_id %in% neighboring_geos$geo_id,]
  # Add HD information (label and designation date) to neighboring geographic units
  # This links each neighboring unit to its associated Historic District(s)
  neighboring_geos <- dplyr::left_join(neighboring_geos, 
                                         sf::st_drop_geometry(i[,c("geo_id", "LABEL", "desig_date")]),
                                         by="geo_id")
  
  # STEP 6: Add area variable:
  neighboring_geos$geo_area <- sf::st_area(neighboring_geos)
  
  # STEP 7: Create summary statistics by Historic District
  # Aggregate demographic data across all neighboring units for each HD
  neighbor_geos_summary <-
    sf::st_drop_geometry(neighboring_geos) %>%
    group_by(LABEL) %>%
      summarise(n_tot = sum(n_tot, na.rm=T),
                n_black = sum(n_black, na.rm=T),
                n_white = sum(n_white, na.rm=T),
                n_other = sum(n_other, na.rm=T),
                desig_year = max(desig_date, na.rm=T),
                tot_area = sum(geo_area, na.rm=T)) %>%
    mutate(desig_yet = ifelse(desig_year<year, 1, 0),
           year = year,
           pop_dens = n_tot / tot_area)
  
  # STEP 8: Return comprehensive results
  rv = list("buffers" = b, 
            "neighbor_geos" = neighboring_geos, 
            "neighbor_geos_summary" = neighbor_geos_summary)
  
  return(rv)
}
```

Function to map those tracts/blocks and see if everything looks good:

```{r}

plot_geos <- function(geo_shp, nearby_geos_shp, geos_in_hds) {
  rv <-
    leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group='buffers', data=nearby_geos_shp[["buffers"]]) %>%
  addPolygons(group= "geos labeled as near HDs",
              data=nearby_geos_shp[["neighbor_geos"]],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~paste0("Geo: ", geo_id, "; HD neighbor: ", LABEL),
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
    addPolygons(group= "geos labeled as in HDs",
              data=geo_shp[geo_shp$geo_id %in% geos_in_hds, ],
              fillColor = "limegreen", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~geo_id,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "HDs",
              data=hd_shp,
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("geos labeled as near HDs", "geos labeled as in HDs", "HDs", "buffers"),
    options = layersControlOptions(collapsed = FALSE)
  )
  
  return(rv)
}

make_lineplot <- function(depend_var, group, title, df) {
  rv <-
    ggplot(df[df$group==group,], 
           aes(x=year, y=!!sym(depend_var), color=treatment_control)) + 
  geom_point() + 
  geom_line() +
  geom_vline(data = df[df$group==group,],
             aes(xintercept = first_decade_desig_copy), 
             color = group, 
             linetype = "dashed", 
             size = 1) +
  ggtitle(title) +
    facet_grid(rows = vars(LABEL), scales = "free_y")
  
  return(rv)
}

```

Function to run regressions:

```{r}

run_regressions <- function(hd_comp_df, near_comp_df, dep_var) {
  
  near_comp_df$LABEL <- gsub(x = near_comp_df$LABEL, pattern = " HD", replacement = "")
  hd_comp_df$LABEL <- gsub(x = hd_comp_df$LABEL, pattern = " HD", replacement = "")
  
  hd_comp_df <-
    hd_comp_df %>%
    select(-ends_with("_prorated"), -desig_year) %>%
    group_by(LABEL, desig_yet, year) %>%
    summarise_all(., sum) %>%
    mutate(pct_black = n_black / n_tot,
           pct_white = n_white / n_tot) %>%
    rename_with(~ paste0(., "_hd"))
  
  near_comp_df <-
    near_comp_df %>%
    select(-desig_year) %>%
    group_by(LABEL, desig_yet, year) %>%
    mutate(pct_black = n_black / n_tot,
           pct_white = n_white / n_tot) %>%
    summarise_all(., sum) %>%
    rename_with(~ paste0(., "_near"))
  
  
  comp_df <- dplyr::full_join(x = hd_comp_df, 
                              y = near_comp_df, 
                              by = c("LABEL_hd"="LABEL_near", 
                                     "desig_yet_hd"="desig_yet_near",
                                     "year_hd"="year_near")) 
  
  comp_df_copy <- comp_df
  comp_df <- comp_df %>% select(starts_with(c("LABEL", "desig_yet", "year", "pct_")))
  
  comp_df <-
    comp_df %>%
    tidyr::pivot_longer(
      cols = starts_with("pct_"),
      names_to = c("group", "treatment_control"),
      names_pattern = "pct_([a-zA-Z]+)_([a-zA-Z]+)",
      values_to = "percent")
  
  comp_df <- dplyr::left_join(x = comp_df, 
                              y = comp_df_copy %>% select("LABEL_hd", "desig_yet_hd", "year_hd", 
                                                          "n_tot_hd", "pop_dens_hd", "pop_dens_near"), 
                              by = c("LABEL_hd", 
                                     "desig_yet_hd",
                                     "year_hd")) %>%
    rename(LABEL = "LABEL_hd",
           desig_yet = "desig_yet_hd",
           year = "year_hd")
  
  # remove HDs that are always HDs or always not HDs during the timeframe
  comp_df <-
    comp_df %>%
    group_by(LABEL) %>%
    mutate(mean_status = mean(desig_yet, na.rm=T)) %>%
    filter(mean_status > 0) %>%
    filter(mean_status < 1)
  
  comp_df$treatment_group <- 0
  comp_df$treatment_group[comp_df$treatment_control=="hd"] <- 1 
  
  comp_df$unit_id <- paste(comp_df$LABEL, comp_df$treatment_control, sep = " ")
  
  # add back total population values
  names(hd_comp_df) <- gsub(x = names(hd_comp_df), pattern = "_hd", replacement = "")
  names(near_comp_df) <- gsub(x = names(near_comp_df), pattern = "_near", replacement = "")
  hd_comp_df$pop_in_unit <- hd_comp_df$n_tot
  near_comp_df$pop_in_unit <- near_comp_df$n_tot
  hd_comp_df$treatment_control <- "hd"
  near_comp_df$treatment_control <- "near"
  
  to_add <-
    dplyr::bind_rows(
      hd_comp_df %>% ungroup() %>% select(LABEL, year, treatment_control, pop_in_unit),
      near_comp_df %>% ungroup() %>% select(LABEL, year, treatment_control, pop_in_unit)
    )
  
  comp_df <- dplyr::left_join(x = comp_df, 
                              y = to_add,
                              by = c("LABEL", "year", "treatment_control"))
  
  comp_df$pop_dens <- ifelse(comp_df$treatment_control=="near", comp_df$pop_dens_near, comp_df$pop_dens_hd)
  comp_df <- comp_df %>% select(-pop_dens_hd, -pop_dens_near)
  
  comp_df$unit_id  <- as.factor(comp_df$unit_id)
  comp_df$LABEL    <- as.factor(comp_df$LABEL)
  comp_df$year     <- as.factor(comp_df$year)
  
  for (grp in c("black", "white")) {
    comp_df_subset <- comp_df[comp_df$group==grp,]
    for (w in c("1", "n_tot_hd")) {
      if (w == "1") {wt=rep(1, nrow(comp_df_subset))} else {wt=comp_df_subset$n_tot_hd}
      # diff in diff analysis for change in the % of residents
      main_formula <- as.formula(paste0(dep_var, 
                                        " ~ treatment_group + desig_yet + treatment_group:desig_yet + unit_id + year"))
      
      w_label_formula <- update(main_formula, . ~ . + LABEL)
      
      diff_in_diff <- lm(main_formula, data = comp_df_subset, weights=wt)
      dind_w_label <- lm(w_label_formula, data = comp_df_subset, weights=wt)
      
      print("_______________________________________________________")
      print(paste0("D-in-D regression for the % of ", grp, " residents, ",
                   ifelse(w=="1", "unweighted", "using population weights")))
      print(summary(diff_in_diff))
      print("__________")
      print("Coef. on treatment variable when we add area fixed effects:")
      print(summary(dind_w_label)$coefficients["treatment_group:desig_yet",])
      # plot(diff_in_diff)
      
    }
  }
    
  
  comp_df <-
    comp_df %>%
    group_by(LABEL, desig_yet) %>%
    mutate(first_decade_desig=min(as.numeric(as.character(year)))) %>%
    mutate(first_decade_desig=ifelse(desig_yet==0, 0, first_decade_desig)) %>%
    ungroup() %>%
    group_by(LABEL) %>%
    mutate(first_decade_desig=max(first_decade_desig)) %>%
    mutate(year_index = as.numeric(as.character(year)) - first_decade_desig)
  
  comp_df$first_decade_desig_copy <- comp_df$first_decade_desig
  comp_df$first_decade_desig[comp_df$treatment_control=="near"] <- 0
  comp_df$year     <- as.numeric(as.character((comp_df$year)))
  comp_df <- comp_df %>%
          group_by(unit_id) %>%
          mutate(unit_id_num = cur_group_id())
  
  
  # Alternate specification:
  # https://bcallaway11.github.io/did/articles/did-basics.html#an-example-with-real-data
  # https://cran.r-project.org/web/packages/did/vignettes/pre-testing.html
      hd.attgt <- did::att_gt(yname = dep_var,
                   gname = "first_decade_desig",
                   idname = "unit_id_num",
                   tname = "year",
                   xformla = ~1,
                   data = comp_df[comp_df$group=="black" & !is.na(comp_df$n_tot_hd),],
                   allow_unbalanced_panel = T,
                   weightsname="n_tot_hd"
                   )
      print(summary(hd.attgt))
      group_effects <- aggte(hd.attgt, type = "group", na.rm=T)
      print(summary(group_effects))
    
  return(comp_df)
}

```

One function to run everything above (we'll use this for robustness checks):

```{r}
run_all <- function(mp, buff_dist, threshold, dep_var) {
  hd_geos60 <- get_geos_in_hd(b60_shp, min_pct = mp, year = 1960)
  hd_geos70 <- get_geos_in_hd(b70_shp, min_pct = mp, year = 1970)
  hd_geos80 <- get_geos_in_hd(b80_shp, min_pct = mp, year = 1980)
  hd_geos90 <- get_geos_in_hd(b90_shp, min_pct = mp, year = 1990)
  hd_geos00 <- get_geos_in_hd(b00_shp, min_pct = mp, year = 2000)
  hd_geos10 <- get_geos_in_hd(b10_shp, min_pct = mp, year = 2010)
  hd_geos20 <- get_geos_in_hd(b20_shp, min_pct = mp, year = 2020)
  gc()
  nearby_geos60 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b60_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1960)
  nearby_geos70 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b70_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1970)
  nearby_geos80 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b80_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos80,threshold, 1980)
  nearby_geos90 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b90_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos90,threshold, 1990)
  gc()
  nearby_geos00 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b00_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos00,threshold, 2000)
  nearby_geos10 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b10_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos10,threshold, 2010)
  nearby_geos20 <- 
    get_neighbor_geos(hd_shp=hd_shp, geo_shp=b20_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos20,threshold, 2020)
  gc()
  
  p60 <- plot_geos(b60_shp, nearby_geos60, hd_geos60$geos_in_hd$geo_id)
  p70 <- plot_geos(b70_shp, nearby_geos70, hd_geos70$geos_in_hd$geo_id)
  p20 <- plot_geos(b20_shp, nearby_geos20, hd_geos20$geos_in_hd$geo_id)
      
  hd_comp_df <- dplyr::bind_rows(hd_geos60[[2]], hd_geos70[[2]], hd_geos80[[2]], hd_geos90[[2]],
                              hd_geos00[[2]], hd_geos10[[2]], hd_geos20[[2]],)
  near_comp_df <- dplyr::bind_rows(nearby_geos60[[3]], nearby_geos70[[3]],nearby_geos80[[3]], nearby_geos90[[3]],
                              nearby_geos00[[3]], nearby_geos10[[3]], nearby_geos20[[3]],)
  
  comp_df <- run_regressions(hd_comp_df, near_comp_df, dep_var)
  
  lineplots = list("black" = NA, "white" = NA, "tot_pop" = NA, "pop_dens" = NA)
  lineplots$black <- make_lineplot(depend_var = "percent", group = "black", title = "Black residents as %", comp_df)
  lineplots$white <- make_lineplot(depend_var = "percent", group = "white", title = "White residents as %", comp_df)
  lineplots$tot_pop <- make_lineplot(depend_var = "pop_in_unit", group = "black", title = "Total population", comp_df)
  lineplots$pop_dens <- make_lineplot(depend_var = "pop_dens", group = "black", title = "Population density", comp_df)
  
  return(list("data" = comp_df, "plot60" = p60, "plot70" = p70, "plot20" = p20,
              "lineplots" = lineplots))
}
```

Call all the functions we created above for our preferred model specification:

```{r}
# ranging the min % between .2 and .6 seems to give reasonable results
mp = 0.25 
hd_geos60 <- get_geos_in_hd(b60_shp, min_pct = mp, year = 1960)
hd_geos70 <- get_geos_in_hd(b70_shp, min_pct = mp, year = 1970)
hd_geos80 <- get_geos_in_hd(b80_shp, min_pct = mp, year = 1980)
hd_geos90 <- get_geos_in_hd(b90_shp, min_pct = mp, year = 1990)
hd_geos00 <- get_geos_in_hd(b00_shp, min_pct = mp, year = 2000)
hd_geos10 <- get_geos_in_hd(b10_shp, min_pct = mp, year = 2010)
hd_geos20 <- get_geos_in_hd(b20_shp, min_pct = mp, year = 2020)
gc()

# the buffer distance is in decimal degrees
buff_dist = .008
threshold = .1

nearby_geos60 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b60_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1960)
nearby_geos70 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b70_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1970)
nearby_geos80 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b80_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos80,threshold, 1980)
nearby_geos90 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b90_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos90,threshold, 1990)
gc()
nearby_geos00 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b00_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos00,threshold, 2000)
nearby_geos10 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b10_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos10,threshold, 2010)
nearby_geos20 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b20_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos20,threshold, 2020)
gc()

```

Plot our classifications in 1960 and 2020, as a gut check:

```{r}

plot_geos(b60_shp, nearby_geos60, hd_geos60$geos_in_hd$geo_id)
plot_geos(b20_shp, nearby_geos20, hd_geos20$geos_in_hd$geo_id)

```

Now compare the demographics of the HD tracts and their neighbors in each year:

```{r}
options(width = 200)

hd_comp_df <- dplyr::bind_rows(hd_geos60[[2]], hd_geos70[[2]], hd_geos80[[2]], hd_geos90[[2]],
                            hd_geos00[[2]], hd_geos10[[2]], hd_geos20[[2]],)
near_comp_df <- dplyr::bind_rows(nearby_geos60[[3]], nearby_geos70[[3]],nearby_geos80[[3]], nearby_geos90[[3]],
                            nearby_geos00[[3]], nearby_geos10[[3]], nearby_geos20[[3]],)

comp_df <- run_regressions(hd_comp_df, near_comp_df, "pop_dens")
```


```{r}
plot_ly(
    data = comp_df[comp_df$group=="black",] %>% arrange(LABEL, year_index),
    x = ~year_index,    # year_index
    y = ~pop_in_unit,  # ~percent_std or ~percent
    color = ~LABEL,  # Specify the grouping variable for color
    linetype = ~as.factor(treatment_control),
    type = "scatter",
    mode = "lines+markers",
    hoverinfo=~as.character(first_decade_desig)
  )
```





# Robustness checks

```{r, fig.height=75}
rv <- run_all(mp=.25, buff_dist=.001, threshold=.1, dep_var = "pop_dens")
rv$lineplots$pop_dens

rv <- run_all(mp=.25, buff_dist=.005, threshold=.1, dep_var = "pop_dens")
rv$lineplots$pop_dens

rv <- run_all(mp=.25, buff_dist=.01, threshold=.1, dep_var = "pop_dens")
rv$lineplots$pop_dens
```




# Matching blocks to each other

```{r}
# clean and combine block shape data
hd_geos <- dplyr::rbind(hd_geos60, )
clean_combine_blocks <- function(b60_shp, b70_shp, b80_shp, b90_shp, b00_shp, b10_shp, b20_shp,
) {
  b <- dplyr::bind_rows(b60_shp, b70_shp, b80_shp, b90_shp, b00_shp, b10_shp, b20_shp)
  b$pop_dens <- b$n_tot / b$geo_area_meters
  b$n_tot_norm = b$n_tot / max(b$n_tot, na.rm=T)
  b$n_black_norm = b$n_black / b$n_tot
  b$n_white_norm = b$n_white / b$n_tot
  b$pop_dense_norm = b$pop_dens / max(b$pop_dens, na.rm=T)
  b$geo_area_meters_norm = b$geo_area_meters / max(b$geo_area_meters, na.rm=T)
}


# get block centroids, calculate distance between all points
get_distances <- function(shp) {
  points <- sf::st_centroid(shp)
  distances <- sf::st_distance(points)
  
  return(distances)
}

b60_dist <- get_distances(b60_shp)
b70_dist <- get_distances(b70_shp)
b80_dist <- get_distances(b80_shp)
b90_dist <- get_distances(b90_shp)
b00_dist <- get_distances(b00_shp)
b10_dist <- get_distances(b10_shp)
b20_dist <- get_distances(b20_shp)





```


