---
title: "Historic district analysi"
author: "Pete Rodrigue & Bob Ward"
date: "2025-08-23"
output: html_document
---

```{r setup}
knitr::opts_chunk$set(echo = TRUE, message=F, warning=F, fig.width = 18, fig.height = 8)
library(readr)
library(sf)
library(leaflet)
library(rstudioapi)
library(dplyr)
library(ggplot2)
library(patchwork)
library(plotly)
```

Set working directory to the place this script is saved:

```{r}
# Getting the path of your current open file
current_path = rstudioapi::getActiveDocumentContext()$path 
setwd(dirname(current_path))
```

Load our data:

```{r}
# load data that has the dates the historic districts were designated
# comes from here: https://planning.dc.gov/page/dc-historic-districts
# hd_data <- readr::read_csv("https://docs.google.com/spreadsheets/d/1Ajl1iAS0NRB7vk_UFDveeWzGkwf3tuiDo-zV9_wtzRM/gviz/tq?tqx=out:csv&sheet=data")
hd_data <- readr::read_csv("hd_data/data.csv")

# load the historic district boundary shape files
# comes from here: https://opendata.dc.gov/datasets/DCGIS::historic-districts/about 
hd_shp <- sf::st_read("Historic_Districts/Historic_Districts.shp")

# load the 2022 ward shape files
# comes from here: https://opendata.dc.gov/datasets/DCGIS::wards-from-2022/about
ward_shp <- sf::st_read("Wards_from_2022/Wards_from_2022.shp")

# load the zoning map:
# comes from here: https://opendata.dc.gov/datasets/DCGIS::zoning-boundaries-zoning-regulations-of-2016/about
zone_shp <- sf::st_read("zoning/Zoning_Boundaries_(Zoning_Regulations_of_2016).shp")

# load & clean census tract data
# please see https://opendata.dc.gov/datasets/DCGIS::census-tracts-in-1970/about
# for example, for more details on variable names
load_clean_tracts <- function(tract_id_var, black_var, white_var, totpop_var, year) {
  # Loads the shapefile, removes unneeded columns, calculates the tract area in meters^2
  shp <- sf::st_read(paste0("tract_data/Census_Tracts_in_", year, 
                            "/Census_Tracts_in_", year, ".shp")) 
  shp <- shp %>% 
    rename("tract_id" = !!sym(tract_id_var),
           "n_black" = !!sym(black_var),
           "n_white" = !!sym(white_var),
           "n_tot" = !!sym(totpop_var)
           ) %>%
    select("tract_id", starts_with("n_")) %>%
    mutate(n_other = n_tot - (n_black + n_white),
           year = year)
  shp$tract_area_meters <- sf::st_area(shp)
  shp <- sf::st_transform(shp, 4326)
  
  return(shp %>% select("year", "tract_id", "n_tot", "n_black", "n_white", "n_other", "tract_area_meters", "geometry"))
}
```

```{r, results="hide", error=F, message=F, warning=F}
t60_shp <- load_clean_tracts("GISJOIN", "B58013", "B58011", "CA4001", 1960)
t70_shp <- load_clean_tracts("GISJOIN", "CEB03", "CEB01", "CY7001", 1970) 
t80_shp <- load_clean_tracts("GISJOIN", "C9D003", "C9D001", "C7L001", 1980)
t90_shp <- load_clean_tracts("TRACTNO", "BLACK", "WHITE", "POPULATION", 1990)
t00_shp <- load_clean_tracts("TRACTNO", "BLACK", "WHITE", "TOTAL", 2000)
t10_shp <- load_clean_tracts("TRACT", "P0010004", "P0010003", "P0010001", 2010)
t20_shp <- load_clean_tracts("TRACT", "P0010004", "P0010003", "P0010001", 2020)
gc()
```


Merge HD data onto HD shapefile, subset to only look at neighborhood HDs:

```{r}
hd_shp <- dplyr::left_join(x = hd_shp, y = hd_data, by = "UNIQUEID")
hd_shp <- hd_shp[hd_shp$Neighborhood_HD==1,]

```

Transform shape files to mercator projection:

```{r}
# convert to mercator projection
zone_shp <- sf::st_transform(zone_shp, 4326)
hd_shp <- sf::st_transform(hd_shp, 4326)
ward_shp <- sf::st_transform(ward_shp, 4326)
```

Subset the zoning map to just look at residential zones:

```{r}
# list zones:
zones_list <- sort(unique(zone_shp$ZR16))
housing_zones <- zones_list[grep(x=zones_list, pattern = "^R|^MU")]
# subset
zone_shp <- zone_shp[zone_shp$ZR16 %in% housing_zones,]

# create simplified labels
zone_shp$ZR16_simple <- "Other"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^RA-")] <- "Apartment zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^R-")] <- "Residential zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^RF-")] <- "Residential flat zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^MU-")] <- "Mixed use zones"

# show on a map:
factpal <- colorFactor(palette = "Set1", domain = zone_shp$ZR16_simple)

leaflet(zone_shp) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~factpal(ZR16_simple), # Apply the color function
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~ZR16,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = TRUE
        )
  ) %>%
  addLegend(pal = factpal, values = ~ZR16_simple, opacity = 0.7, title = NULL,
    position = "bottomright")
```


Calculate the total amount of residential and MU land in DC:

```{r}
# need to fix broken geometries:
fix_geo_if_broken <- function(shp) {
  if (min(sf::st_is_valid(shp)) == 0) {
    print("Fixing geometry...")
    return(sf::st_make_valid(shp))
  } else {
      return(shp)
    }
  }

zone_shp <- fix_geo_if_broken(zone_shp)
hd_shp <- fix_geo_if_broken(hd_shp)
ward_shp <- fix_geo_if_broken(ward_shp)
t60_shp <- fix_geo_if_broken(t60_shp)
t70_shp <- fix_geo_if_broken(t70_shp)
t80_shp <- fix_geo_if_broken(t80_shp)
t90_shp <- fix_geo_if_broken(t90_shp)
t00_shp <- fix_geo_if_broken(t00_shp)
t10_shp <- fix_geo_if_broken(t10_shp)
t20_shp <- fix_geo_if_broken(t20_shp)


zone_shp$area_meters <- sf::st_area(zone_shp)
zone_shp$area_acres <- as.vector(zone_shp$area_meters * 0.000247105)
total_zone_acres <- sum(zone_shp$area_acres, na.rm=T)
```


Total land area covered by HDs over time:

```{r}
# get shape areas:
hd_shp$area_meters <- sf::st_area(hd_shp)
hd_shp$area_acres <- as.vector(hd_shp$area_meters * 0.000247105)

years <- c(1960, 1970, 1980, 1990, 2000, 2010, 2025)
land_areas <- rep(NA, length(years))
counter <- 1
for (year in years) { # Land area covered by HDs by year:
  land_area <- sum(hd_shp$area_acres[hd_shp$desig_date < year])
  land_areas[counter] <- land_area
  counter <- counter + 1
}

p <- data.frame(years, land_areas, round(100*land_areas / total_zone_acres,0))
names(p) <- c("Year", 
              "Area covered by by Historic Districts, in Acres",
              "Percent of 2016 residential zone covered by Neighborhood HD")
plot1 <-
  ggplot(p, 
       aes(x=Year, 
           y=`Area covered by by Historic Districts, in Acres`)) + 
  geom_bar(stat = "identity", fill="#0f9535") +
  geom_text(aes(label = round(`Area covered by by Historic Districts, in Acres`, 0), vjust = -1.7)) +
  ylab("Acres") +
  theme_minimal() +
  ggtitle('Acres covered by "neighborhood historic districts" has steadily increased over time')

plot2 <-
  ggplot(p, 
       aes(x=Year, 
           y=`Percent of 2016 residential zone covered by Neighborhood HD`)) + 
  geom_line(color="#0f9535", size=.75) +
  geom_point(color="#0f9535") +
  geom_text(aes(label = paste0(`Percent of 2016 residential zone covered by Neighborhood HD`, "%")), vjust = -1.7) +
  theme_minimal() +
  ylab("Percent") +
  ggtitle('And the % of residential area covered by HDs has more than doubled since 1980')

plot1 + plot2
```


Let's quickly compare which HDs were designated before vs after 1980:

```{r}

hd_shp$flag_1980 <- 0
hd_shp$flag_1980[hd_shp$desig_date < 1980] <- 1

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group= "Designated before 1980",
              data=hd_shp[hd_shp$flag_1980==1,],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "Designated after 1980",
              data=hd_shp[hd_shp$flag_1980==0,],
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("Designated before 1980", "Designated after 1980"),
    options = layersControlOptions(collapsed = FALSE)
  )

```


Now let's look and see how HD changed over time, in terms of % black residents and % white residents, compared to nearby neighborhoods (tracts) that were not in HDs.

This will have a few steps:

1. Take a given HD.
2. Get the intersection of the HD with census tracts. If at least X% of the census tract area is in the HD, we'll count it as part of the HD. (We'll vary X as robustness check later)
3. Create a buffer around the HD of distance Y (we'll vary Y as a robustness check later). Run another intersection with the census tracts and that buffer. Count any tracts that touch the buffer but are not in an HD as "comparison" tracts. 
4. Note the % of white and black residents in each HD and those HDs comparison tracts.
5. See how that changes over time.


```{r}
# drop some very small HDs that are like a single circle
# just dropped anything smaller than 10 acres
hd_shp <-
  hd_shp %>%
  filter(!(LABEL %in% c("Emerald St HD",
                       "Grant Rd HD",
                       "Mount Vernon Triangle HD",
                       "Grant Circle HD",
                       "Union Market"
                       )))

get_tracts_in_hd <- function(shp, min_pct, year) {
  # get the tracts that are in each HD in a given year
  
  i <- sf::st_intersection(x=shp, y=hd_shp)
  i$i_area <- sf::st_area(i)
  i$pct_of_tract_area <- as.vector(i$i_area / i$tract_area_meters)
  
  tracts_in_hd <- i[i$pct_of_tract_area > min_pct, 
                    c("year", "tract_id", "LABEL",
                      "n_tot", "n_black", "n_white", "n_other",
                      "desig_date", "pct_of_tract_area")]
  tracts_in_hd_summary <-
    tracts_in_hd %>%
    mutate(n_tot_prorated = n_tot * pct_of_tract_area,
           n_black_prorated = n_black * pct_of_tract_area,
           n_white_prorated = n_white * pct_of_tract_area,
           n_other_prorated = n_other * pct_of_tract_area) %>%
    select("year", "LABEL", "tract_id", starts_with("n_"), "desig_date") %>%
    group_by(LABEL) %>%
      summarise(n_tot = sum(n_tot),
                n_black = sum(n_black),
                n_white = sum(n_white),
                n_other = sum(n_other),
                n_tot_prorated = sum(n_tot_prorated),
                n_black_prorated = sum(n_black_prorated),
                n_white_prorated = sum(n_white_prorated),
                n_other_prorated = sum(n_other_prorated),
                desig_year = max(desig_date, na.rm=T)) %>%
    mutate(desig_yet = ifelse(desig_year<year, 1, 0), 
           year = year)
  
    rv = list("tracts_in_hd"=tracts_in_hd, "summary"=sf::st_drop_geometry(tracts_in_hd_summary))
    
    return(rv)
}

# turn off spherical geometry (s2)
sf_use_s2(FALSE)
# ranging the min % between .2 and .6 seems to give reasonable results
mp = 0.25 # TODO: run analysis varying this factor
hd_tracts60 <- get_tracts_in_hd(t60_shp, min_pct = mp, year = 1960)
hd_tracts70 <- get_tracts_in_hd(t70_shp, min_pct = mp, year = 1970)
hd_tracts80 <- get_tracts_in_hd(t80_shp, min_pct = mp, year = 1980)
hd_tracts90 <- get_tracts_in_hd(t90_shp, min_pct = mp, year = 1990)
hd_tracts00 <- get_tracts_in_hd(t00_shp, min_pct = mp, year = 2000)
hd_tracts10 <- get_tracts_in_hd(t10_shp, min_pct = mp, year = 2010)
hd_tracts20 <- get_tracts_in_hd(t20_shp, min_pct = mp, year = 2020)
gc()
```

Plot where the tracts "inside" the HDs were for 2020:

```{r}
plot_tracts_in_hds <- function(shp, tracts_in_hds) {
  rv <-
    leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group= "tracts labeled as in HDs",
              data=shp[shp$tract_id %in% tracts_in_hds, ],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~tract_id,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "HDs",
              data=hd_shp,
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("tracts labeled as in HDs", "HDs"),
    options = layersControlOptions(collapsed = FALSE)
  )
  
  return(rv)
}
```

```{r}
plot_tracts_in_hds(t60_shp, hd_tracts60$tracts_in_hd$tract_id)
plot_tracts_in_hds(t70_shp, hd_tracts70$tracts_in_hd$tract_id)
plot_tracts_in_hds(t80_shp, hd_tracts80$tracts_in_hd$tract_id)
plot_tracts_in_hds(t90_shp, hd_tracts90$tracts_in_hd$tract_id)
plot_tracts_in_hds(t00_shp, hd_tracts00$tracts_in_hd$tract_id)
plot_tracts_in_hds(t10_shp, hd_tracts10$tracts_in_hd$tract_id)
plot_tracts_in_hds(t20_shp, hd_tracts20$tracts_in_hd$tract_id)
```

Now get a list of neighboring tracts:

```{r}
get_neighbor_tracts <- function(hd_shp, t_shp, buffer_dist, tracts_in_hd, remove_tract_thresh, year) {
  # first make a buffer around the HDs
  b <- sf::st_buffer(hd_shp, dist = buffer_dist)
  # then get the intersection of the buffer and the tracts
  i <- sf::st_intersection(x=t_shp, y=b)
  # remove tracts that have already been classified as within an HD
  i <- i[!(i$tract_id %in% tracts_in_hd$tracts_in_hd$tract_id),]
  # also remove any tracts for which more than X% of an HD is in that tract
  hd_shp$area_meters <- sf::st_area(hd_shp)
  hd_tract <- sf::st_intersection(x=t_shp, y=hd_shp)
  hd_tract$intersect_area <- sf::st_area(hd_tract)
  hd_tract$pct_area <- as.vector(hd_tract$intersect_area / hd_tract$area_meters)
  tracts_to_remove <- hd_tract$tract_id[hd_tract$pct_area > remove_tract_thresh]
  neighboring_tracts <- i[!(i$tract_id %in% tracts_to_remove),]
  
  # finally, remove
  neighboring_tracts <- t_shp[t_shp$tract_id %in% neighboring_tracts$tract_id,]
  neighboring_tracts <- dplyr::left_join(neighboring_tracts, 
                                         sf::st_drop_geometry(i[,c("tract_id", "LABEL", "desig_date")]),
                                         by="tract_id")
  
  neighbor_tracts_summary <-
    sf::st_drop_geometry(neighboring_tracts) %>%
    group_by(LABEL) %>%
      summarise(n_tot = sum(n_tot),
                n_black = sum(n_black),
                n_white = sum(n_white),
                n_other = sum(n_other),
                desig_year = max(desig_date, na.rm=T)) %>%
    mutate(desig_yet = ifelse(desig_year<year, 1, 0),
           year = year)
  
  rv = list("buffers" = b, 
            "neighbor_tracts" = neighboring_tracts, 
            "neighbor_tracts_summary" = neighbor_tracts_summary)
  
  return(rv)
}

buff_dist = .005
threshold = .1

nearby_tracts60 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t60_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts70,threshold, 1960)
nearby_tracts70 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t70_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts70,threshold, 1970)
nearby_tracts80 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t80_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts80,threshold, 1980)
nearby_tracts90 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t90_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts90,threshold, 1990)
gc()
nearby_tracts00 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t00_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts00,threshold, 2000)
nearby_tracts10 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t10_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts10,threshold, 2010)
nearby_tracts20 <- 
  get_neighbor_tracts(hd_shp=hd_shp, t_shp=t20_shp, buffer_dist=buff_dist, tracts_in_hd=hd_tracts20,threshold, 2020)
gc()

plot_neighbor_tracts <- function(shp) {
  rv <-
    leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group='buffers', data=shp[["buffers"]]) %>%
  addPolygons(group= "tracts labeled as near HDs",
              data=shp[["neighbor_tracts"]],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~paste0("Tract: ", tract_id, "; HD neighbor: ", LABEL),
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "HDs",
              data=hd_shp[hd_shp$desig_date < 2025,],
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("tracts labeled as near HDs", "HDs", "buffers"),
    options = layersControlOptions(collapsed = FALSE)
  )
  
  return(rv)
}

```


```{r}
plot_neighbor_tracts(nearby_tracts60)
plot_neighbor_tracts(nearby_tracts20)
```

Now compare the demographics of the HD tracts and their neighbors in each year:

```{r}

hd_comp_df <- dplyr::bind_rows(hd_tracts60[[2]], hd_tracts70[[2]], hd_tracts80[[2]], hd_tracts90[[2]],
                            hd_tracts00[[2]], hd_tracts10[[2]], hd_tracts20[[2]],)



near_comp_df <- dplyr::bind_rows(nearby_tracts60[[3]], nearby_tracts70[[3]],nearby_tracts80[[3]], nearby_tracts90[[3]],
                            nearby_tracts00[[3]], nearby_tracts10[[3]], nearby_tracts20[[3]],)

hd_comp_df <-
  hd_comp_df %>%
  select(-ends_with("_prorated"), -desig_year) %>%
  group_by(LABEL, desig_yet, year) %>%
  summarise_all(., sum) %>%
  mutate(pct_black = n_black / n_tot,
         pct_white = n_white / n_tot) %>%
  rename_with(~ paste0(., "_hd"))

near_comp_df <-
  near_comp_df %>%
  select(-desig_year) %>%
  group_by(LABEL, desig_yet, year) %>%
  mutate(pct_black = n_black / n_tot,
         pct_white = n_white / n_tot) %>%
  summarise_all(., sum) %>%
  rename_with(~ paste0(., "_near"))

comp_df <- dplyr::full_join(x = hd_comp_df, 
                            y = near_comp_df, 
                            by = c("LABEL_hd"="LABEL_near", 
                                   "desig_yet_hd"="desig_yet_near",
                                   "year_hd"="year_near")) %>%
  select(starts_with(c("LABEL", "desig_yet", "year", "pct_")))

comp_df <-
  comp_df %>%
  tidyr::pivot_longer(
    cols = starts_with("pct_"),
    names_to = c("group", "treatment_control"),
    names_pattern = "pct_([a-zA-Z]+)_([a-zA-Z]+)",
    values_to = "percent")

comp_df$treated <- 0
comp_df$treated[comp_df$treatment_control=="hd"] <- 1

# diff in diff analysis for change in the % of black residents
diff_in_diff <- lm(percent ~                 # outcome: % of white or black residents
                     treated +               # "treatment": whether tract is in a HD or not
                     desig_yet_hd +          # pre/post indicator: whether HD was designated yet
                     treated:desig_yet_hd +  # D-in-D estimator: effect of treatment after implemented
                     as.factor(LABEL_hd)  +  # fixed effect for HD area
                     as.factor(year_hd),     # fixed effect for year
                   data = comp_df[comp_df$group=="black",])

summary(diff_in_diff)

# diff in diff analysis for change in the % of white residents
diff_in_diff <- lm(percent ~                 # outcome: % of white or black residents
                     treated +               # "treatment": whether tract is in a HD or not
                     desig_yet_hd +          # pre/post indicator: whether HD was designated yet
                     treated:desig_yet_hd +  # D-in-D estimator: effect of treatment after implemented
                     as.factor(LABEL_hd)  +  # fixed effect for HD area
                     as.factor(year_hd),     # fixed effect for year
                   data = comp_df[comp_df$group=="white",])

summary(diff_in_diff)



plot_ly(comp_df[comp_df$group=="black",] %>% arrange(LABEL_hd, year_hd),
                   x = ~year_hd,
                   y = ~percent,
                   linetype = ~as.factor(treatment_control),
                   hovertext = ~paste0("Tract types: ", treatment_control, "\nDesignated yet: ", desig_yet_hd),
                   color = ~LABEL_hd, # Group lines by this variable
                   type = "scatter",
                   mode = "lines+markers") %>%
      layout(title = "% black residents in each historic district areas before and after HD created")

plot_ly(comp_df[comp_df$group=="white",] %>% arrange(LABEL_hd, year_hd),
                   x = ~year_hd,
                   y = ~percent,
                   linetype = ~as.factor(treatment_control),
                   hovertext = ~paste0("Tract types: ", treatment_control, "\nDesignated yet: ", desig_yet_hd),
                   color = ~LABEL_hd, # Group lines by this variable
                   type = "scatter",
                   mode = "lines+markers") %>%
      layout(title = "% white residents in each historic district areas before and after HD created")
```












