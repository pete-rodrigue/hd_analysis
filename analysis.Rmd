---
title: "Historic district analysis"
author: "Pete Rodrigue & Bob Ward"
date: "2025-08-23"
output: html_document
---

This Rmarkdown file shows the code we used to analyze demographic change over time in and outside of historic districts. 


```{r setup}
knitr::opts_chunk$set(echo = TRUE, message=F, warning=F, fig.width = 11.5, fig.height = 6.5)
library(readr)
library(sf)
library(leaflet)
library(rstudioapi)
library(dplyr)
library(ggplot2)
library(patchwork)
library(plotly)
```

Set working directory to the place this script is saved:

```{r}
# Getting the path of your current open file
current_path = rstudioapi::getActiveDocumentContext()$path 
setwd(dirname(current_path))
```

Load our data. We'll first do the analysis using Census tracts, and then later use Census blocks.

```{r}
# load data that has the dates the historic districts were designated
# comes from here: https://planning.dc.gov/page/dc-historic-districts
# hd_data <- readr::read_csv("https://docs.google.com/spreadsheets/d/1Ajl1iAS0NRB7vk_UFDveeWzGkwf3tuiDo-zV9_wtzRM/gviz/tq?tqx=out:csv&sheet=data")
hd_data <- readr::read_csv("hd_data/data.csv")

# load the historic district boundary shape files
# comes from here: https://opendata.dc.gov/datasets/DCGIS::historic-districts/about 
hd_shp <- sf::st_read("Historic_Districts/Historic_Districts.shp")

# load the 2022 ward shape files
# comes from here: https://opendata.dc.gov/datasets/DCGIS::wards-from-2022/about
ward_shp <- sf::st_read("Wards_from_2022/Wards_from_2022.shp")

# load the zoning map:
# comes from here: https://opendata.dc.gov/datasets/DCGIS::zoning-boundaries-zoning-regulations-of-2016/about
zone_shp <- sf::st_read("zoning/Zoning_Boundaries_(Zoning_Regulations_of_2016).shp")

# load & clean census tract data
# please see https://opendata.dc.gov/datasets/DCGIS::census-tracts-in-1970/about
# for example, for more details on variable names
load_clean_tracts <- function(geo_id_var, black_var, white_var, totpop_var, year) {
  # Loads the shapefile, removes unneeded columns, calculates the tract area in meters^2
  shp <- sf::st_read(paste0("tract_data/Census_Tracts_in_", year, 
                            "/Census_Tracts_in_", year, ".shp")) 
  shp <- shp %>% 
    rename("geo_id" = !!sym(geo_id_var),
           "n_black" = !!sym(black_var),
           "n_white" = !!sym(white_var),
           "n_tot" = !!sym(totpop_var)
           ) %>%
    select("geo_id", starts_with("n_")) %>%
    mutate(n_other = n_tot - (n_black + n_white),
           year = year)
  shp$geo_area_meters <- sf::st_area(shp)
  shp <- sf::st_transform(shp, 4326)
  
  return(shp %>% select("year", "geo_id", "n_tot", "n_black", "n_white", "n_other", "geo_area_meters", "geometry"))
}
```

```{r, results="hide", error=F, message=F, warning=F}
t60_shp <- load_clean_tracts("GISJOIN", "B58013", "B58011", "CA4001", 1960)
t70_shp <- load_clean_tracts("GISJOIN", "CEB03", "CEB01", "CY7001", 1970) 
t80_shp <- load_clean_tracts("GISJOIN", "C9D003", "C9D001", "C7L001", 1980)
t90_shp <- load_clean_tracts("TRACTNO", "BLACK", "WHITE", "POPULATION", 1990)
t00_shp <- load_clean_tracts("TRACTNO", "BLACK", "WHITE", "TOTAL", 2000)
t10_shp <- load_clean_tracts("TRACT", "P0010004", "P0010003", "P0010001", 2010)
t20_shp <- load_clean_tracts("TRACT", "P0010004", "P0010003", "P0010001", 2020)
gc()
```


Merge historic distrit (HD) data onto HD shapefile, subset to only look at neighborhood HDs:

```{r}
hd_shp <- dplyr::left_join(x = hd_shp, y = hd_data, by = "UNIQUEID")
hd_shp <- hd_shp[hd_shp$Neighborhood_HD==1,]

```

Transform shape files to mercator projection:

```{r}
# convert to mercator projection
zone_shp <- sf::st_transform(zone_shp, 4326)
hd_shp <- sf::st_transform(hd_shp, 4326)
ward_shp <- sf::st_transform(ward_shp, 4326)
```

Let's overlay HDs onto DC's zoning map. 

```{r}
# list zones:
zones_list <- sort(unique(zone_shp$ZR16))
housing_zones <- zones_list[grep(x=zones_list, pattern = "^R|^MU")]
# subset
zone_shp <- zone_shp[zone_shp$ZR16 %in% housing_zones,]

# create simplified labels
zone_shp$ZR16_simple <- "Other"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^RA-")] <- "Apartment zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^R-")] <- "Residential zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^RF-")] <- "Residential flat zones"
zone_shp$ZR16_simple[grep(x=zone_shp$ZR16, pattern="^MU-")] <- "Mixed use zones"

# show on a map:
factpal <- colorFactor(palette = "Set1", domain = zone_shp$ZR16_simple)

leaflet(zone_shp) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(fillColor = ~factpal(ZR16_simple), # Apply the color function
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~ZR16,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = TRUE
        )
  ) %>%
  addLegend(pal = factpal, values = ~ZR16_simple, opacity = 0.7, title = NULL,
    position = "bottomright")
```


Calculate the total amount of residential and MU land in DC:

```{r}
# need to fix broken geometries:
fix_geo_if_broken <- function(shp) {
  if (min(sf::st_is_valid(shp)) == 0) {
    print("Fixing geometry...")
    return(sf::st_make_valid(shp))
  } else {
      return(shp)
    }
  }

zone_shp <- fix_geo_if_broken(zone_shp)
hd_shp <- fix_geo_if_broken(hd_shp)
ward_shp <- fix_geo_if_broken(ward_shp)
t60_shp <- fix_geo_if_broken(t60_shp)
t70_shp <- fix_geo_if_broken(t70_shp)
t80_shp <- fix_geo_if_broken(t80_shp)
t90_shp <- fix_geo_if_broken(t90_shp)
t00_shp <- fix_geo_if_broken(t00_shp)
t10_shp <- fix_geo_if_broken(t10_shp)
t20_shp <- fix_geo_if_broken(t20_shp)


zone_shp$area_meters <- sf::st_area(zone_shp)
zone_shp$area_acres <- as.vector(zone_shp$area_meters * 0.000247105)
total_zone_acres <- sum(zone_shp$area_acres, na.rm=T)
```


Total and % of land area covered by HDs over time:

```{r}
# get shape areas:
hd_shp$area_meters <- sf::st_area(hd_shp)
hd_shp$area_acres <- as.vector(hd_shp$area_meters * 0.000247105)

years <- c(1960, 1970, 1980, 1990, 2000, 2010, 2025)
land_areas <- rep(NA, length(years))
counter <- 1
for (year in years) { # Land area covered by HDs by year:
  land_area <- sum(hd_shp$area_acres[hd_shp$desig_date < year])
  land_areas[counter] <- land_area
  counter <- counter + 1
}

p <- data.frame(years, land_areas, round(100*land_areas / total_zone_acres,0))
names(p) <- c("Year", 
              "Area covered by by Historic Districts, in Acres",
              "Percent of 2016 residential zone covered by Neighborhood HD")
plot1 <-
  ggplot(p, 
       aes(x=Year, 
           y=`Area covered by by Historic Districts, in Acres`)) + 
  geom_bar(stat = "identity", fill="#0f9535") +
  geom_text(aes(label = round(`Area covered by by Historic Districts, in Acres`, 0), vjust = -1.7)) +
  ylab("Acres") +
  theme_minimal() +
  ggtitle('Acres covered by "neighborhood historic districts"\nhas steadily increased over time')

plot2 <-
  ggplot(p, 
       aes(x=Year, 
           y=`Percent of 2016 residential zone covered by Neighborhood HD`)) + 
  geom_line(color="#0f9535", size=.75) +
  geom_point(color="#0f9535") +
  geom_text(aes(label = paste0(`Percent of 2016 residential zone covered by Neighborhood HD`, "%")), vjust = -1.7) +
  theme_minimal() +
  ylab("Percent") +
  ggtitle('And the % of residential area covered\nby HDs has more than doubled since 1980')

plot1 + plot2
```


Let's quickly compare which HDs were designated before vs after 1980:

```{r}

hd_shp$flag_1980 <- 0
hd_shp$flag_1980[hd_shp$desig_date < 1980] <- 1

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group= "Designated before 1980",
              data=hd_shp[hd_shp$flag_1980==1,],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "Designated after 1980",
              data=hd_shp[hd_shp$flag_1980==0,],
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("Designated before 1980", "Designated after 1980"),
    options = layersControlOptions(collapsed = FALSE)
  )

```

We'll remove some very small HDs for the next part (like HDs that are a single circle):

```{r}
# Drop some very small HDs that are like a single circle
# We just dropped anything smaller than 10 acres
hd_shp <-
  hd_shp %>%
  filter(!(LABEL %in% c("Emerald St HD",
                       "Grant Rd HD",
                       "Mount Vernon Triangle HD",
                       "Grant Circle HD",
                       "Union Market"
                       )))

# turn off spherical geometry (s2)
sf_use_s2(FALSE)
```

Now let's look and see how HDs changed over time, in terms of % black residents and % white residents, compared to nearby neighborhoods (tracts) that were not in HDs.

This will have a few steps:

1. Take a given HD.
2. Get the intersection of the HD with census tracts. If at least X% of the census tract area is in the HD, we'll count it as part of the HD.
3. Create a buffer around the HD of distance Y. Run another intersection with the census tracts and that buffer. Count any tracts that touch the buffer but are not in an HD as comparison tracts. 
4. Note the % of white and black residents in each HD and those HDs comparison tracts.
5. See how those respective percentages change over time. 


Function to find which tracts/blocks are in which HDs:

```{r}
get_geos_in_hd <- function(shp, min_pct, year) {
  # This function gets the tracts that are in each HD in a given year
  # shp: the tract or block shapefile (an sf shapefile object)
  # min_pct: the minimum % of the tract or block that must be in the HD to count as part of the HD (a decimal # between 0 and 1)
  # year: the year (an integer like 1980)
  i <- sf::st_intersection(x=shp, y=hd_shp)
  i$i_area <- sf::st_area(i)
  i$pct_of_geo_area <- as.vector(i$i_area / i$geo_area_meters)
  
  geos_in_hd <- i[i$pct_of_geo_area > min_pct, 
                    c("year", "geo_id", "LABEL",
                      "n_tot", "n_black", "n_white", "n_other",
                      "desig_date", "pct_of_geo_area")]
  geos_in_hd_summary <-
    geos_in_hd %>%
    mutate(n_tot_prorated = n_tot * pct_of_geo_area,
           n_black_prorated = n_black * pct_of_geo_area,
           n_white_prorated = n_white * pct_of_geo_area,
           n_other_prorated = n_other * pct_of_geo_area) %>%
    select("year", "LABEL", "geo_id", starts_with("n_"), "desig_date") %>%
    group_by(LABEL) %>%
      summarise(n_tot = sum(n_tot, na.rm=T),
                n_black = sum(n_black, na.rm=T),
                n_white = sum(n_white, na.rm=T),
                n_other = sum(n_other, na.rm=T),
                n_tot_prorated = sum(n_tot_prorated, na.rm=T),
                n_black_prorated = sum(n_black_prorated, na.rm=T),
                n_white_prorated = sum(n_white_prorated, na.rm=T),
                n_other_prorated = sum(n_other_prorated, na.rm=T),
                desig_year = max(desig_date, na.rm=T)) %>%
    mutate(desig_yet = ifelse(desig_year<year, 1, 0), 
           year = year)
  
    rv = list("geos_in_hd"=geos_in_hd, "summary"=sf::st_drop_geometry(geos_in_hd_summary))
    
    return(rv)
}


```

Function to find which tracts/blocks are nearby but not inside the HDs:

```{r}
get_neighbor_geos <- function(hd_shp, geo_shp, buffer_dist, geos_in_hd, remove_geo_thresh, year) {
  # first make a buffer around the HDs
  b <- sf::st_buffer(hd_shp, dist = buffer_dist)
  # then get the intersection of the buffer and the tracts
  i <- sf::st_intersection(x=geo_shp, y=b)
  # remove tracts that have already been classified as within an HD
  i <- i[!(i$geo_id %in% geos_in_hd$geos_in_hd$geo_id),]
  # also remove any tracts/blocks for which more than X% of an HD is in that tract/block
  hd_shp$area_meters <- sf::st_area(hd_shp)
  hd_geo <- sf::st_intersection(x=geo_shp, y=hd_shp)
  hd_geo$intersect_area <- sf::st_area(hd_geo)
  hd_geo$pct_area <- as.vector(hd_geo$intersect_area / hd_geo$area_meters)
  geos_to_remove <- hd_geo$geo_id[hd_geo$pct_area > remove_geo_thresh]
  neighboring_geos <- i[!(i$geo_id %in% geos_to_remove),]
  
  # finally, remove
  neighboring_geos <- geo_shp[geo_shp$geo_id %in% neighboring_geos$geo_id,]
  neighboring_geos <- dplyr::left_join(neighboring_geos, 
                                         sf::st_drop_geometry(i[,c("geo_id", "LABEL", "desig_date")]),
                                         by="geo_id")
  
  neighbor_geos_summary <-
    sf::st_drop_geometry(neighboring_geos) %>%
    group_by(LABEL) %>%
      summarise(n_tot = sum(n_tot, na.rm=T),
                n_black = sum(n_black, na.rm=T),
                n_white = sum(n_white, na.rm=T),
                n_other = sum(n_other, na.rm=T),
                desig_year = max(desig_date, na.rm=T)) %>%
    mutate(desig_yet = ifelse(desig_year<year, 1, 0),
           year = year)
  
  rv = list("buffers" = b, 
            "neighbor_geos" = neighboring_geos, 
            "neighbor_geos_summary" = neighbor_geos_summary)
  
  return(rv)
}
```

Function to map those tracts/blocks and see if everything looks good:

```{r}

plot_geos <- function(geo_shp, nearby_geos_shp, geos_in_hds) {
  rv <-
    leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(group='buffers', data=nearby_geos_shp[["buffers"]]) %>%
  addPolygons(group= "geos labeled as near HDs",
              data=nearby_geos_shp[["neighbor_geos"]],
              fillColor = "skyblue", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~paste0("Geo: ", geo_id, "; HD neighbor: ", LABEL),
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
    addPolygons(group= "geos labeled as in HDs",
              data=geo_shp[geo_shp$geo_id %in% geos_in_hds, ],
              fillColor = "limegreen", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~geo_id,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addPolygons(group= "HDs",
              data=hd_shp,
              fillColor = "hotpink", 
              fillOpacity = 0.7,
              weight = 1,
              opacity = 1,
              color = "white",
              label=~LABEL,
              highlightOptions = highlightOptions(weight = 3,
                                                  color = "white",
                                                  bringToFront = FALSE
        ) 
  ) %>%
  addLayersControl(
    overlayGroups = c("geos labeled as near HDs", "geos labeled as in HDs", "HDs", "buffers"),
    options = layersControlOptions(collapsed = FALSE)
  )
  
  return(rv)
}

```

Function to run regressions:

```{r}
run_regressions <- function(hd_comp_df, near_comp_df, weights=F) {
  
  hd_comp_df <-
    hd_comp_df %>%
    select(-ends_with("_prorated"), -desig_year) %>%
    group_by(LABEL, desig_yet, year) %>%
    summarise_all(., sum) %>%
    mutate(pct_black = n_black / n_tot,
           pct_white = n_white / n_tot) %>%
    rename_with(~ paste0(., "_hd"))
  
  near_comp_df <-
    near_comp_df %>%
    select(-desig_year) %>%
    group_by(LABEL, desig_yet, year) %>%
    mutate(pct_black = n_black / n_tot,
           pct_white = n_white / n_tot) %>%
    summarise_all(., sum) %>%
    rename_with(~ paste0(., "_near"))
  
  comp_df <- dplyr::full_join(x = hd_comp_df, 
                              y = near_comp_df, 
                              by = c("LABEL_hd"="LABEL_near", 
                                     "desig_yet_hd"="desig_yet_near",
                                     "year_hd"="year_near")) 
  
  comp_df_copy <- comp_df
  comp_df <- comp_df %>% select(starts_with(c("LABEL", "desig_yet", "year", "pct_")))
  
  comp_df <-
    comp_df %>%
    tidyr::pivot_longer(
      cols = starts_with("pct_"),
      names_to = c("group", "treatment_control"),
      names_pattern = "pct_([a-zA-Z]+)_([a-zA-Z]+)",
      values_to = "percent")
  
  comp_df <- dplyr::left_join(x = comp_df, 
                              y = comp_df_copy %>% select("LABEL_hd", "desig_yet_hd", "year_hd", "n_tot_hd"), 
                              by = c("LABEL_hd", 
                                     "desig_yet_hd",
                                     "year_hd"))
  
  # remove HDs that are always HDs or always not HDs during the timeframe
  comp_df <-
    comp_df %>%
    group_by(LABEL_hd) %>%
    mutate(mean_status = mean(desig_yet_hd, na.rm=T)) %>%
    filter(mean_status > 0) %>%
    filter(mean_status < 1)
  
  comp_df$treated <- 0
  comp_df$treated[comp_df$treatment_control=="hd"] <- 1
  
  comp_df$LABEL_hd <- as.factor(comp_df$LABEL_hd)
  comp_df$year_hd  <- as.factor(comp_df$year_hd)
  
  if (weights) {
    # diff in diff analysis for change in the % of black residents
    diff_in_diff_b <- lm(percent ~               # outcome: % of white or black residents
                         treated +               # "treatment": whether tract is in a HD or not
                         desig_yet_hd +          # pre/post indicator: whether HD was designated yet
                         treated:LABEL_hd +      # controlling for average % within each set of tracts/blocks (either in or near each HD)   
                         treated:desig_yet_hd +  # D-in-D estimator: effect of treatment after implemented
                         LABEL_hd  +             # fixed effect for HD area
                         year_hd,                # fixed effect for year
                       data = comp_df[comp_df$group=="black",],
                       weights=n_tot_hd)
    
    # diff in diff analysis for change in the % of white residents
    diff_in_diff_w <- lm(percent ~               # outcome: % of white or black residents
                         treated +               # "treatment": whether tract is in a HD or not
                         desig_yet_hd +          # pre/post indicator: whether HD was designated yet
                        treated:LABEL_hd +       # controlling for average % within each set of tracts/blocks (either in or near each HD)
                         treated:desig_yet_hd +  # D-in-D estimator: effect of treatment after implemented
                         LABEL_hd  +             # fixed effect for HD area
                         year_hd,                # fixed effect for year
                       data = comp_df[comp_df$group=="white",],
                       weights=n_tot_hd)
    text_bit <- ", weighted by HD population"
  } else {
    # diff in diff analysis for change in the % of black residents
    diff_in_diff_b <- lm(percent ~                 # outcome: % of white or black residents
                         treated +               # "treatment": whether tract is in a HD or not
                         desig_yet_hd +          # pre/post indicator: whether HD was designated yet
                         treated:LABEL_hd +      # controlling for average % within each set of tracts/blocks (either in or near each HD)
                         treated:desig_yet_hd +  # D-in-D estimator: effect of treatment after implemented
                         LABEL_hd  +             # fixed effect for HD area
                         year_hd,                # fixed effect for year
                       data = comp_df[comp_df$group=="black",])
    
    # diff in diff analysis for change in the % of white residents
    diff_in_diff_w <- lm(percent ~                 # outcome: % of white or black residents
                         treated +               # "treatment": whether tract is in a HD or not
                         desig_yet_hd +          # pre/post indicator: whether HD was designated yet
                         treated:LABEL_hd +      # controlling for average % within each set of tracts/blocks (either in or near each HD)
                         treated:desig_yet_hd +  # D-in-D estimator: effect of treatment after implemented
                         LABEL_hd  +             # fixed effect for HD area
                         year_hd,                # fixed effect for year
                       data = comp_df[comp_df$group=="white",])
    text_bit <- ", NOT weighted by HD population"
  }
  
  print("__________________________________")
  print(paste0("D-in-D regression for the % of black residents", text_bit))
  print(summary(diff_in_diff_b))
  
  print("__________________________________")
  print(paste0("D-in-D regression for the % of white residents", text_bit))
  print(summary(diff_in_diff_w))
  
  comp_df <-
    comp_df %>%
    group_by(LABEL_hd, desig_yet_hd) %>%
    mutate(first_decade_desig=min(as.numeric(as.character(year_hd)))) %>%
    mutate(first_decade_desig=ifelse(desig_yet_hd==0, 0, first_decade_desig)) %>%
    ungroup() %>%
    group_by(LABEL_hd) %>%
    mutate(first_decade_desig=max(first_decade_desig)) %>%
    mutate(year_index = as.numeric(as.character(year_hd)) - first_decade_desig)

  comp_df <-
    comp_df %>%
    ungroup() %>%
    group_by(LABEL_hd, group, treatment_control) %>%
    mutate(percent_std = (percent - mean(percent, na.rm=T)) / sd(percent, na.rm=T))
    
  return(comp_df)
}

```



Call all the functions we created above:

```{r}
# ranging the min % between .2 and .6 seems to give reasonable results
mp = 0.25 
hd_geos60 <- get_geos_in_hd(t60_shp, min_pct = mp, year = 1960)
hd_geos70 <- get_geos_in_hd(t70_shp, min_pct = mp, year = 1970)
hd_geos80 <- get_geos_in_hd(t80_shp, min_pct = mp, year = 1980)
hd_geos90 <- get_geos_in_hd(t90_shp, min_pct = mp, year = 1990)
hd_geos00 <- get_geos_in_hd(t00_shp, min_pct = mp, year = 2000)
hd_geos10 <- get_geos_in_hd(t10_shp, min_pct = mp, year = 2010)
hd_geos20 <- get_geos_in_hd(t20_shp, min_pct = mp, year = 2020)
gc()

# the buffer distance is in decimal degrees
buff_dist = .005
threshold = .1

nearby_tracts60 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t60_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1960)
nearby_tracts70 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t70_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1970)
nearby_tracts80 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t80_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos80,threshold, 1980)
nearby_tracts90 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t90_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos90,threshold, 1990)
gc()
nearby_tracts00 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t00_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos00,threshold, 2000)
nearby_tracts10 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t10_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos10,threshold, 2010)
nearby_tracts20 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=t20_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos20,threshold, 2020)
gc()



```

Plot our classifications in 1960 and 2020, as a gut check:

```{r}

plot_geos(t60_shp, nearby_tracts60, hd_geos60$geos_in_hd$geo_id)
plot_geos(t20_shp, nearby_tracts20, hd_geos20$geos_in_hd$geo_id)

```

Now compare the demographics of the HD tracts and their neighbors in each year:

```{r}
options(width = 200)

hd_comp_df <- dplyr::bind_rows(hd_geos60[[2]], hd_geos70[[2]], hd_geos80[[2]], hd_geos90[[2]],
                            hd_geos00[[2]], hd_geos10[[2]], hd_geos20[[2]],)
near_comp_df <- dplyr::bind_rows(nearby_tracts60[[3]], nearby_tracts70[[3]],nearby_tracts80[[3]], nearby_tracts90[[3]],
                            nearby_tracts00[[3]], nearby_tracts10[[3]], nearby_tracts20[[3]],)

comp_df <- run_regressions(hd_comp_df, near_comp_df, weights = T)
comp_df <- run_regressions(hd_comp_df, near_comp_df, weights = F)


plot_ly(
    data = comp_df[comp_df$group=="black",] %>% arrange(LABEL_hd, year_index),
    x = ~year_index,
    y = ~percent,  # ~percent_std
    color = ~LABEL_hd,  # Specify the grouping variable for color
    linetype = ~as.factor(treatment_control),
    type = "scatter",
    mode = "lines+markers"
  )



```






Now we're going to repeat all of that, but using block groups instead of tracts. We will have to rely on sightly different versions of the Census data to do this, downloaded from NHGIS rather than Open Data DC. We're also only going back to 1970, since that's the data I could find relatively easily.


Load and clean block data:

```{r}
# b70_shp <- sf::st_read("block_shapes/US_block_1970/US_block_1970.shp")
# b70_shp <- b70_shp[b70_shp$STATE70=="11",]
# sf::st_write(b70_shp, "block_shapes/DC_block_1970/DC_block_1970.shp")

b70_shp <- sf::st_read("block_shapes/DC_block_1970/DC_block_1970.shp")
b80_shp <- sf::st_read("block_shapes/DC_block_1980/DC_block_1980.shp")
b90_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2000_110_block_1990/DC_block_1990.shp")
b00_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2000_110_block_2000/DC_block_2000.shp")
b10_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2010_110_block_2010/DC_block_2010.shp")
b20_shp <- sf::st_read("block_shapes/nhgis0092_shapefile_tl2020_110_block_2020/DC_block_2020.shp")

b70_df <- readr::read_csv("block_data/nhgis0093_ds96_1970_block.csv")
b80_df <- readr::read_csv("block_data/nhgis_ds104_1980_block_11.csv")
b90_df <- readr::read_csv("block_data/nhgis0092_ds120_1990_block.csv")
b00_df <- readr::read_csv("block_data/nhgis0092_ds147_2000_block.csv")
b10_df <- readr::read_csv("block_data/nhgis0092_ds172_2010_block.csv")
b20_df <- readr::read_csv("block_data/nhgis0092_ds258_2020_block.csv")

clean_block_data <- function(shp, df, shp_b_id, df_b_id, var_prefix, df_n_black, df_n_white, drop_var="", year) {
  shp <- shp %>% select(!!sym(shp_b_id)) %>% rename("geo_id" = !!sym(shp_b_id))
  if (drop_var!="") {df <- df %>% select(-!!sym(drop_var))}
  df <- df %>% 
    select(!!sym(df_b_id), starts_with(var_prefix)) %>%
    rowwise() %>%
    mutate(n_tot = sum(c_across(starts_with(var_prefix))))
    
  df <- df %>%
    rename("geo_id" = !!sym(df_b_id),
           "n_black" = !!sym(df_n_black),
           "n_white" = !!sym(df_n_white)) %>%
    select(-starts_with(var_prefix)) %>%
    mutate(n_other = n_tot - (n_black + n_white))
  
  shp <- dplyr::left_join(shp, df, by="geo_id")
  shp <- sf::st_transform(shp, 4326)
  shp$geo_area_meters <- sf::st_area(shp)
  shp$year <- year
  
  return(shp)
}

# 1970 block data has to be specially cleaned, see https://forum.ipums.org/t/race-ethnicity-data-at-a-block-level-from-1970/6178
b70_df$c_black <- b70_df$CM6001 + b70_df$CM6002
b70_df$c_other <- b70_df$CM6003 + b70_df$CM6004
b70_df$c_white <- b70_df$CM5001 + b70_df$CM5002 - b70_df$c_black - b70_df$c_other

b70_shp <- clean_block_data(b70_shp, b70_df, "GISJOIN", "GISJOIN", "c_", "c_black", "c_white", year=1970)
b80_shp <- clean_block_data(b80_shp, b80_df, "GISJOIN", "GISJOIN", "C9D0", "C9D002", "C9D001", year=1980)
b90_shp <- clean_block_data(b90_shp, b90_df, "GISJOIN", "GISJOIN", "EUY0", "EUY002", "EUY001", year=1990)
b00_shp <- clean_block_data(b00_shp, b00_df, "GISJOIN", "GISJOIN", "FYE0", "FYE002", "FYE001", year=2000)
b10_shp <- clean_block_data(b10_shp, b10_df, "GISJOIN", "GISJOIN", "H7X", "H7X003", "H7X002", "H7X001", year=2010)
b20_shp <- clean_block_data(b20_shp, b20_df, "GISJOIN", "GISJOIN", "U7J", "U7J003", "U7J002", "U7J001", year=2020)

rm(b70_df, b80_df, b90_df, b00_df, b10_df, b20_df)

plot(sf::st_geometry(b70_shp["geo_id"]))
```


Get the blocks in the HDs:

```{r}
gc()
mp = 0.25 # TODO: run analysis varying this factor
hd_geos70 <- get_geos_in_hd(b70_shp, min_pct = mp, year = 1970)
hd_geos80 <- get_geos_in_hd(b80_shp, min_pct = mp, year = 1980)
hd_geos90 <- get_geos_in_hd(b90_shp, min_pct = mp, year = 1990)
hd_geos00 <- get_geos_in_hd(b00_shp, min_pct = mp, year = 2000)
hd_geos10 <- get_geos_in_hd(b10_shp, min_pct = mp, year = 2010)
hd_geos20 <- get_geos_in_hd(b20_shp, min_pct = mp, year = 2020)
```


Get the blocks neighboring the HDs:

```{r}
gc()
buff_dist = .005
threshold = .1

nearby_blocks70 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b70_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos70,threshold, 1970)
nearby_blocks80 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b80_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos80,threshold, 1980)
nearby_blocks90 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b90_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos90,threshold, 1990)
nearby_blocks00 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b00_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos00,threshold, 2000)
nearby_blocks10 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b10_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos10,threshold, 2010)
nearby_blocks20 <- 
  get_neighbor_geos(hd_shp=hd_shp, geo_shp=b20_shp, buffer_dist=buff_dist, geos_in_hd=hd_geos20,threshold, 2020)

```

Again let's peek at a map to make sure everything looks ok:

```{r}
plot_geos(b70_shp, nearby_blocks70, hd_geos70$geos_in_hd$geo_id)
plot_geos(b20_shp, nearby_blocks20, hd_geos20$geos_in_hd$geo_id)
```





Now compare the demographics of the HD blocks and their neighbors in each year:

```{r}
options(width = 200)
hd_comp_df <- dplyr::bind_rows(hd_geos70[[2]], hd_geos80[[2]], hd_geos90[[2]], 
                               hd_geos00[[2]], hd_geos10[[2]], hd_geos20[[2]],)

near_comp_df <- dplyr::bind_rows(nearby_blocks70[[3]], nearby_blocks80[[3]], nearby_blocks90[[3]], 
                                 nearby_blocks00[[3]], nearby_blocks10[[3]], nearby_blocks20[[3]],)

comp_df <- run_regressions(hd_comp_df, near_comp_df, weights = T)
comp_df <- run_regressions(hd_comp_df, near_comp_df, weights = F)

```


